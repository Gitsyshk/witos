#include <init.h>
#include <mmc/mmc.h>

#define CONTROL_PADCONF_MMC1_BASE 0x48002144 
#define CONTROL_PADCONF_MMC1_END 0x48002156

// #define CM_ICLKEN1_CORE 0x48004a10
// #define CM_FCLKEN1_CORE 0x48004a00

#define MMCHS1_BASE 0x4809c000
#define SYSCONFIG        0x010
#define SYSSTATUS        0x014
#define CON              0x02c
#define HCTL             0x128
#define CAPA             0x140
#define CUR_CAPA         0x148
#define SYSCTL           0x12c
#define CMD              0x10c
#define ARG              0x108
#define STAT             0x130
#define PSTATE           0x124
#define BLK              0x104
#define IE               0x134
#define RSP10           0x110
#define RSP32           0x114
#define RSP54           0x118
#define RSP76           0x11c

#define REF_CLK MB(96)

#define mmc_readl(offset)  readl(VA((offset) + MMCHS1_BASE))
#define mmc_writel(offset, val) writel(VA((offset) + MMCHS1_BASE), val)

static int omap3_send_cmd(int cmd, u32 arg, RESP type, u32 *resp)
{
	u32 val;
	u32 reg_arg = 0;

	switch (type)
	{
	case R1:
	case R5:
	case R6:
	case R7:
		reg_arg = 3 << 19 | 2 << 16;
		break;
	case R2:
		reg_arg = 1 << 19 | 1 << 16;
		break;
	case R3:
	case R4:
		reg_arg = 2 << 16;
		break;
	case R1b:
		reg_arg = 3 << 19 | 3 << 16;
		break;
	case NONE:
		reg_arg = 0;
		break;
	default:
		break;
	}

	reg_arg |= cmd << 24;

	// reg_arg |= 1 << 4;

	while (1)
	{
		val = mmc_readl(PSTATE);
		if (!(val & (1 << 1)))
			break;
		printf("%s(), line %d PSTATE = 0x%x\n", __func__, __LINE__, val);
	}

	mmc_writel(BLK, 0x200);
	mmc_writel(ARG, arg);
	// mmc_writel(IE, 0x7f << 16 | 1 << 8 | 0x37);
	mmc_writel(CMD, reg_arg);

	while (1)
	{
		val = mmc_readl(STAT);
		if (val & (1 << 16))
		{
			val = mmc_readl(SYSCTL);
			val |= 1 << 25;
			mmc_writel(SYSCTL, val);

			while (mmc_readl(SYSCTL) & (1 << 25));


			val = mmc_readl(SYSCTL);
			val |= 1 << 26;
			mmc_writel(SYSCTL, val);

			while (mmc_readl(SYSCTL) & (1 << 26));
			printf("cmd %d timeout!\n", cmd);

			return -EBUSY;
			
		}

		if (val & 1)
		{
			if (type == NONE)
				return 0;

			resp[0] = mmc_readl(RSP10);
			resp[1] = mmc_readl(RSP32);
			resp[2] = mmc_readl(RSP54);
			resp[3] = mmc_readl(RSP76);
			printf("cmd = %d: resp10 = 0x%08x, resp32 = 0x%08x, resp54 = 0x%08x, resp76 = 0x%08x\n",
					cmd, mmc_readl(RSP10), mmc_readl(RSP32), mmc_readl(RSP54), mmc_readl(RSP76));
			break;
		}
	}
	return 0;
}


static void omap3_set_clk(int clk_rate)
{
	u32 val;
	u32 clk_div;

	assert(clk_rate);

	clk_div = REF_CLK / clk_rate;
	
	val = mmc_readl(SYSCTL);
	val &= ~(1 << 2);
	mmc_writel(SYSCTL, val);

	val = mmc_readl(SYSCTL);
	val &= ~(0x3ff << 6);
	val |= clk_div << 6;
	mmc_writel(SYSCTL, val);

	while (1)
	{
		val = mmc_readl(SYSCTL);
		if (val & (1 << 1))
			break;

		printf("SYSCTL = %x clk_div = %d\n", val, clk_div);
	}

	val = mmc_readl(SYSCTL);
	val |= 1 << 2;
	mmc_writel(SYSCTL, val);
}

 static int __INIT__ omap3_mmc_init()
 {
	u32 val;
	u32 addr = CONTROL_PADCONF_MMC1_BASE;

#if 1

	while (addr <= CONTROL_PADCONF_MMC1_END)
	{
		writew(VA(addr), 1 << 8 | 3 << 3);
		addr += 2;
	}

	// Enable Functional Clock and Interface Clock
	val = readl(VA(CM_ICLKEN1_CORE));
	val |= 1 << 24;
	writel(VA(CM_ICLKEN1_CORE), val);

	val = readl(VA(CM_FCLKEN1_CORE));
	val |= 1 << 24;
	writel(VA(CM_FCLKEN1_CORE), val);
	udelay(1000);

	// Software rest host controller

	val = mmc_readl(SYSCONFIG);
	val |= 1 << 1;
	mmc_writel(SYSCONFIG, val);

	printf("%s(), line %d\n", __func__, __LINE__);

	while (1)
	{
		val = mmc_readl(SYSSTATUS);
		if (val & 1)
			break;
	}

	val = mmc_readl(SYSCTL);
	val |= 1 << 24;
	mmc_writel(SYSCTL, val);

	while (mmc_readl(SYSCTL) & (1 << 24));

	// Set Capability
	val = mmc_readl(CAPA);
	val &= ~(7 << 24);
	val |= 6 << 24;
	mmc_writel(CAPA, val);

	// val = mmc_readl(CUR_CAPA);
	mmc_writel(CON, 1);

	// Enable SDBUS Clock
	mmc_writel(HCTL, 0x6 << 9);
#if 0
	mmc_writel(HCTL, 0x6 << 9 | 1 << 8);

	while (1)
	{
		val = mmc_readl(HCTL);
		if (val & (1 << 8))
			break;
		printf("HCTL = %x\n", val);
	}
#endif

	val = mmc_readl(SYSCTL);
	val |= 1;
	mmc_writel(SYSCTL, val);
	// set clock to 150K
	omap3_set_clk(KB(160));
#if 1

	val = mmc_readl(HCTL);
	val |= 1 << 8;
	mmc_writel(HCTL, val);

	while (1)
	{
		val = mmc_readl(HCTL);
		if (val & (1 << 8))
			break;
		printf("HCTL = %x\n", val);
	}
#endif

	// mmc_writel(IE, 0x7f << 16 | 1 << 8 | 0x37);
	mmc_writel(IE, 0x307f0033);
	// start Initialization
	val = mmc_readl(CON);
	val |= 1 << 1;
	mmc_writel(CON, val);

	mmc_writel(CMD, 0);

	while (1)
	{
		val = mmc_readl(STAT);
		if (val & 1)
			break;
		printf("line %d: STAT = %x\n", __LINE__, val);
	}

	val = mmc_readl(STAT);
	val |= 1;
	mmc_writel(STAT, val);

	mmc_writel(CMD, 0);

	while (1)
	{
		val = mmc_readl(STAT);
		if (val & 1)
			break;
		printf("line %d: STAT = %x\n", __LINE__, val);
	}

	val = mmc_readl(STAT);
	val |= 1;
	mmc_writel(STAT, val);

	val = mmc_readl(CON);
	val &= ~(1 << 1);
	mmc_writel(CON, val);

	mmc_writel(STAT, 0xffffffff);

	// Change clock to 400K
	omap3_set_clk(KB(400));

	//cmd0

#endif
	int i;
	u32 resp[4];

	omap3_send_cmd(MMC_GO_IDLE_STATE, 0, NONE, NULL);

	omap3_send_cmd(MMC_SEND_EXT_CSD, 0x1aa, R7, resp);

	for (i = 0; i < 10; i++)
	{
		omap3_send_cmd(MMC_APP_CMD, 0x0, R1, resp);
		omap3_send_cmd(SD_APP_OP_COND, 0x40ff8000, R3, resp);
		if (resp[0] && (1 << 31))
			break;
	}

	omap3_send_cmd(MMC_ALL_SEND_CID, 0, R2, resp);

	printf("%s(), line %d\n", __func__, __LINE__);

	return 0;
}


DRIVER_INIT(omap3_mmc_init);
